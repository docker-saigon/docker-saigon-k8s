Managing Containers at Scale with CoreOS and Kubernetes
YAPC Asia 2015

Kelsey Hightower
CoreOS
kelsey.hightower@coreos.com
@kelseyhightower

* Managing applications today

Machines and applications are tightly coupled.

- Configuration management
- Infrastructure as code
- Scripting frameworks (Fabric, Capistrano, Bash scripts)

* Configuration Management

Model applications as a collection of resources.

- Configure users, services, refrigerators, ...

Ansible playbook:

.code manifests/hello-playbook.yml 

* Configuration Management

Map machines to applications.

- Machines are first class citizens
- Everything else is a resource of the machine

Machine inventory:

.code ansible/hosts

* Configuration management demo

* Configuration Management

Not a good fit for application management

- Machine centric view of the world
- Weak data consistency
- Orphaned resources 
- Applications pinned to machines

* We have to move past shell scripting, or I will replace you with a scheduler.

* Managing applications in the future

Decouple applications from the machines.

- Use configuration management to manage machines not applications
- Use a better abstraction for applications (Containers)
- Use application centric tools (Kubernetes)

* Containers

Unix processes not lightweight Virtual Machines

- application + dependencies = image
- Runtime environment (cgroups, namespaces, env vars)

.image images/container.png

* Containers

Building container images.

.code docker/large-dockerfile

Total size: 500MB

* Containers

Building container images.

- Build applications in a dedicated build container or CI
- Ship build artifacts, not build environments

Remix

.code docker/small-dockerfile

Total size: 4MB

* Kubernetes

Container management, scheduling, and service discovery.

- API driven application management
- Agents monitor endpoints for state changes (real-time)
- Controllers enforce desired state
- Labels identify resources (nodes, applications, services)

* Kubernetes

High level concepts

- node
- pod
- scheduler
- replication controller
- service

* Node

Runs containers and proxies service requests.

- docker
- kubelet
- proxy

.image images/kubernetes-nodes-2.png

* Node Manifest

.code manifests/node.json

* Pod

Represents a logical application.

- One or more containers
- Shared namespaces

.image images/pod.png

* Pod Manifest

.code manifests/pod.json

* Scheduler

Schedules pods to run on nodes.

- Global scheduler for long running jobs
- Best fit chosen based on pod requirements
- Pluggable

.image images/kubernetes-scheduler.png

* Replication Controller

Manages a replicated set of pods.

- Creates pods from a template
- Ensures desired number of pods are running
- Online resizing 

.image images/kubernetes-rc.png

* Replication Controller

Manages a replicated set of pods.

- Creates pods from a template
- Ensures desired number of pods are running
- Self-healing 

.image images/kubernetes-rc-reschedule.png

* Replication Controller Manifest

.code manifests/replication-controller.json

* Service

Service discovery for pods.

- Proxy runs on each node
- Virutal IP per service (avoid port collisions)
- Basic round-robin algorithm
- Dynamic backends based on label queries 

* Service Manifest

.code manifests/service.json

* Real world example

* pgview

Request

  curl http://api.pgview.com -d @rpc/sqlfeatures.json

Response

  {
      "id": 0,
      "result": {
          "Features": [
              "Embedded Ada",
              "Embedded C",
              "Embedded COBOL",
              "Embedded Fortran",
              "Embedded MUMPS",
              "Embedded Pascal",
              ...
          ],
          "Count": 672
      },
      "error": null
  }

* pgview

Postgres database info as a service.

Application requirements:

- Horizontally scalable 
- Dedicated Memcache instance per application (local caching)
- Postgres database

Operational Requirements:

- Automated service discovery
- Zero downtime application upgrades

* Kubernetes in action
